from __future__ import annotations

from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import Any, Dict, Optional
from datetime import datetime
from sqlalchemy.orm import Session
from sqlalchemy import text
from pathlib import Path
import json

from .llm import interpret_with_openai
from .db import get_db
from app.mm_pricing import compute_mm_prices
from .erc20 import allowance, transfer, transfer_from
from .config import USDC_ADDRESS, VSP_ADDRESS, MM_ADDRESS

app = FastAPI(title="VeriSphere App API", version="0.1.0")

# ============================================================
# Deployment artifact path (mounted from core repo)
# ============================================================
BROADCAST_PATH = Path("/app/broadcast/Deploy.s.sol/43113/run-latest.json")

@app.on_event("startup")
async def check_deployment():
    """Log warning if deployment artifact is missing (no crash)."""
    if not BROADCAST_PATH.exists():
        print(f"Warning: Deployment artifact not found at {BROADCAST_PATH}")
        print("  â†’ Run 'forge script ... --broadcast' in core/ first, then restart containers.")
    else:
        print(f"Deployment artifact found: {BROADCAST_PATH}")

@app.get("/api/contracts")
def get_contracts():
    """Return latest deployed contract addresses from Foundry broadcast JSON."""
    if not BROADCAST_PATH.exists():
        raise HTTPException(500, f"Deployment artifact not found at {BROADCAST_PATH}")

    try:
        with BROADCAST_PATH.open() as f:
            data = json.load(f)

        contracts = {}
        for tx in data.get("transactions", []):
            name = tx.get("contractName")
            addr = tx.get("contractAddress")
            if name and addr:
                contracts[name] = addr

        # Fallbacks from config.py
        contracts.setdefault("USDC", USDC_ADDRESS)
        contracts.setdefault("VSPToken", VSP_ADDRESS)

        print(f"Returning {len(contracts)} contracts from /api/contracts")
        return contracts

    except Exception as e:
        import traceback
        print("ERROR in /api/contracts:", str(e))
        print(traceback.format_exc())
        raise HTTPException(500, f"Failed to load contracts: {str(e)}")

# ============================================================
# Existing endpoints (unchanged)
# ============================================================

class InterpretRequest(BaseModel):
    input: str
    model: Optional[str] = None

@app.get("/healthz")
def healthz() -> Dict[str, str]:
    return {"ok": "true"}

@app.post("/interpret")
def interpret(req: InterpretRequest) -> Dict[str, Any]:
    if not req.input or not isinstance(req.input, str):
        raise HTTPException(status_code=400, detail="Invalid input")
    try:
        return interpret_with_openai(req.input, model=req.model or "gpt-4o-mini")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Interpret failed: {str(e)}")

# ============================================================
# Market Maker API (unchanged)
# ============================================================

def oracle_timestamp() -> str:
    return datetime.utcnow().isoformat() + "Z"

@app.get("/mm/quote")
def mm_quote(db: Session = Depends(get_db)):
    net_vsp, unit_au, spread_rate = db.execute(
        text("""
            SELECT net_vsp, unit_au, spread_rate
            FROM mm_state
            WHERE id = TRUE
        """)
    ).one()
    prices = compute_mm_prices(
        net_vsp=net_vsp,
        unit_au=unit_au,
        spread_rate=spread_rate,
    )
    return {
        "market_price_usdc": prices["market_usd"],
        "buy_usdc": prices["buy_usd"],
        "sell_usdc": prices["sell_usd"],
        "ts": oracle_timestamp(),
    }

class MMTradeRequest(BaseModel):
    user_address: str
    vsp_amount: int
    expected_price_usdc: float

@app.post("/mm/buy")
def mm_buy(req: MMTradeRequest, db: Session = Depends(get_db)):
    usdc_needed = int(req.vsp_amount * req.expected_price_usdc * 1_000_000)
    if allowance(USDC_ADDRESS, req.user_address, MM_ADDRESS) < usdc_needed:
        raise HTTPException(400, "USDC allowance too low")
    with db.begin():
        net_vsp, unit_au, spread_rate = db.execute(
            text("SELECT net_vsp, unit_au, spread_rate FROM mm_state WHERE id = TRUE FOR UPDATE")
        ).one()
        prices = compute_mm_prices(net_vsp, unit_au, spread_rate)
        transfer_from(USDC_ADDRESS, req.user_address, MM_ADDRESS, usdc_needed)
        transfer(VSP_ADDRESS, req.user_address, req.vsp_amount * 10**18)
        db.execute(
            text("UPDATE mm_state SET net_vsp = :n WHERE id = TRUE"),
            {"n": net_vsp + req.vsp_amount},
        )
    return {"ok": True}

@app.post("/mm/sell")
def mm_sell(req: MMTradeRequest, db: Session = Depends(get_db)):
    usdc_out = int(req.vsp_amount * req.expected_price_usdc * 1_000_000)
    if allowance(VSP_ADDRESS, req.user_address, MM_ADDRESS) < req.vsp_amount * 10**18:
        raise HTTPException(400, "VSP allowance too low")
    with db.begin():
        net_vsp, unit_au, spread_rate = db.execute(
            text("SELECT net_vsp, unit_au, spread_rate FROM mm_state WHERE id = TRUE FOR UPDATE")
        ).one()
        transfer_from(VSP_ADDRESS, req.user_address, MM_ADDRESS, req.vsp_amount * 10**18)
        transfer(USDC_ADDRESS, req.user_address, usdc_out)
        db.execute(
            text("UPDATE mm_state SET net_vsp = :n WHERE id = TRUE"),
            {"n": net_vsp - req.vsp_amount},
        )
    return {"ok": True}
